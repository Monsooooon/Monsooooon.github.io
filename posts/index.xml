<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Monsooooon</title><link>https://monsooooon.github.io/posts/</link><description>Recent content in Posts on Monsooooon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 11 Feb 2022 09:38:45 +0800</lastBuildDate><atom:link href="https://monsooooon.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective_Modern_Cpp_Item_21</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_21/</link><pubDate>Fri, 11 Feb 2022 09:38:45 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_21/</guid><description>Item 21: Prefer std::make_unique and std::make_shared to direct use of new.
three make functions
std::make_unique std::make_shared std::allocate_shared how to use? // deprecated: std::unique_ptr&amp;lt;Widget&amp;gt; upw(new Widget); auto upw(std::make_unique&amp;lt;Widget&amp;gt;()); // deprecated: std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget); auto spw(std::make_shared&amp;lt;Widget&amp;gt;()); why use? exception safety consider the following code:
processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), computePriority()); possible execution order (depends on compiler)
new Widget computerPriority &amp;ndash;&amp;gt; cause exception!! build shared_ptr if the second step throws an exception, the new-ed Widget will NEVER be deleted.</description><content type="html"><![CDATA[<blockquote>
<p>Item 21: Prefer std::make_unique and
std::make_shared to direct use of new.</p>
</blockquote>
<p>three make functions</p>
<ul>
<li>std::make_unique</li>
<li>std::make_shared</li>
<li>std::allocate_shared</li>
</ul>
<h2 id="how-to-use">how to use?</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// deprecated: std::unique_ptr&lt;Widget&gt; upw(new Widget);
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">upw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// deprecated: std::shared_ptr&lt;Widget&gt; spw(new Widget);
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">spw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div><h2 id="why-use">why use?</h2>
<h3 id="exception-safety">exception safety</h3>
<p>consider the following code:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">),</span> <span class="n">computePriority</span><span class="p">());</span>
</code></pre></div><p>possible execution order (depends on compiler)</p>
<ol>
<li>new Widget</li>
<li>computerPriority &ndash;&gt; cause exception!!</li>
<li>build shared_ptr</li>
</ol>
<p>if the second step throws an exception, the new-ed Widget will <strong>NEVER</strong> be deleted.</p>
<p>correct way with <code>std::make_shared</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">computePriority</span><span class="p">());</span>
</code></pre></div><blockquote>
<p>The best way to do that is to make sure that when you use
new directly, you immediately pass the result to a smart pointer constructor in a
statement that does nothing else.</p>
</blockquote>
<p>or split this statement into two parts:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">spw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>
<span class="n">processWidget</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spw</span><span class="p">),</span> <span class="n">computePriority</span><span class="p">());</span>
</code></pre></div><h3 id="memory-allocation-efficiency">memory allocation efficiency</h3>
<p>both the object and the smart_ptr need mem allocations.<br>
we want to do it in one single shot.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// two mem allocs for two data parts
</span><span class="c1"></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">upw</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">);</span>

<span class="c1">// one single mem alloc for two data parts
</span><span class="c1"></span><span class="k">auto</span> <span class="nf">upw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">());</span>
</code></pre></div>]]></content></item><item><title>Effective_Modern_Cpp_Item_23</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_23/</link><pubDate>Fri, 11 Feb 2022 09:38:45 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_23/</guid><description>Item 23: Understand std::move and std::forward.
our focus:
std::move std::forward they are functions.
std::move std::move casts its arguement to an rvalue. it&amp;rsquo;s better to call it &amp;lsquo;rvalue cast&amp;rsquo;.
it does the cast. it doesn&amp;rsquo;t move.
in some cases, the std::move-ed object is still copied, not moved
class Annotation { public: Annotation(const std::string text): value(std::move(text)) { // try move text (call string&amp;#39;s move ctor) //... } private: std::string value; } class string { public: string(const string&amp;amp; rhs); // copy ctpr string(string&amp;amp;&amp;amp; rhs); // move ctor // .</description><content type="html"><![CDATA[<blockquote>
<p>Item 23: Understand std::move and std::forward.</p>
</blockquote>
<p>our focus:</p>
<ul>
<li>std::move</li>
<li>std::forward</li>
</ul>
<p>they are functions.</p>
<h2 id="stdmove">std::move</h2>
<p>std::move casts its arguement to an rvalue. it&rsquo;s better to call it &lsquo;rvalue cast&rsquo;.</p>
<p><strong>it does the cast. it doesn&rsquo;t move.</strong></p>
<p>in some cases, the std::move-ed object is still copied, not moved</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Annotation</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Annotation</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">)</span><span class="o">:</span> 
  <span class="n">value</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">text</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// try move text (call string&#39;s move ctor)
</span><span class="c1"></span>    <span class="c1">//...
</span><span class="c1"></span>  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">string</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">string</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>  <span class="c1">// copy ctpr
</span><span class="c1"></span>  <span class="n">string</span><span class="p">(</span><span class="n">string</span><span class="o">&amp;&amp;</span> <span class="n">rhs</span><span class="p">);</span>       <span class="c1">// move ctor
</span><span class="c1"></span>  <span class="c1">// ...
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p><code>std::move</code> the <code>const std::string</code>, produce an <code>rvalue const string</code> type object. <strong>the constness remains</strong></p>
<p>therefore, the string&rsquo;s move ctor cannot use it. but the copy ctor can, because <strong>an lvalue-reference-to-const is permitted to bind to a const rvalue.</strong></p>
<h2 id="stdforward">std::forward</h2>
<p>used together when</p>
<ol>
<li>template function</li>
<li>T&amp;&amp; as paramter</li>
<li>need to pass param to other functions</li>
</ol>
<p>std::forward will convert the <code>T&amp;&amp;</code> into rvalue or lvalue, depending on the original initialization varible&rsquo;s type.</p>
<p>common usage:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{};</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;inside lvalue process&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;inside rvalue process&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">logAndProcess</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;log&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">process</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">param</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
    <span class="n">logAndProcess</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>   <span class="c1">// log inside lvalue process
</span><span class="c1"></span>    <span class="n">logAndProcess</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">w</span><span class="p">));</span>  <span class="c1">// log inside rvalue process
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div>]]></content></item><item><title>Effective_Cpp_Item_33</title><link>https://monsooooon.github.io/posts/effective_cpp_item_33/</link><pubDate>Thu, 10 Feb 2022 14:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_33/</guid><description>Item 33: Avoid hiding inherited names.
In Cpp, names be be hidden.
for example:
double x; void func() { int x; cin &amp;gt;&amp;gt; x; // read the int x, not the double x; } the name searching rule is bottom-up, from local to larget scope, and finally to global scope.
the same rule applies to member functions in inheritance.
class Base { private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); .</description><content type="html"><![CDATA[<blockquote>
<p>Item 33: Avoid hiding inherited names.</p>
</blockquote>
<p>In Cpp, names be be hidden.<br>
for example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="kt">double</span> <span class="n">x</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// read the int x, not the double x;
</span><span class="c1"></span><span class="p">}</span>
</code></pre></div><p>the name searching rule is bottom-up, from local to larget scope, and finally to global scope.</p>
<p>the same rule applies to member functions in inheritance.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf4</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div><p>the <code>mf1</code> and <code>mf3</code> names in Derived class hide the one in Base class</p>
<p>therefore,</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
<span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">();</span>
<span class="n">d</span><span class="p">.</span><span class="n">mf1</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// complier error, because Derived::mf1 hides Base::mf1(int);
</span><span class="c1"></span>
<span class="n">d</span><span class="p">.</span><span class="n">mf3</span><span class="p">();</span>
<span class="n">d</span><span class="p">.</span><span class="n">mf3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span> <span class="c1">// complier error, because Derived::m3 hides Base::mf3(double);
</span></code></pre></div><p>Name hiding can happens even the function arguments &amp; return types are different.</p>
<p>To address this problem, you should use <code>using</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">mf1</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf2</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf1</span><span class="p">;</span> <span class="c1">// make all things in Base named mf1 and mf3
</span><span class="c1"></span>    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">mf3</span><span class="p">;</span> <span class="c1">// visible (and public) in Derived’s scope
</span><span class="c1"></span>    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">mf1</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf3</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">mf4</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div><p>now the above code works</p>
<p>In summary:</p>
<blockquote>
<p>If you inherit from a base class with <strong>overloaded functions</strong> and you want to redefine or override only some of them, you need
to include a using declaration for each name you’d otherwise be hiding.
If you don’t, some of the names you’d like to inherit will be hidden.</p>
</blockquote>
<blockquote>
<p>a using declaration makes all inherited functions with a given
name visible in the derived class.</p>
</blockquote>
]]></content></item><item><title>Effective_Cpp_Item_32</title><link>https://monsooooon.github.io/posts/effective_cpp_item_32/</link><pubDate>Thu, 10 Feb 2022 13:43:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_32/</guid><description>Item 32: Make sure public inheritance models “is-a.”
the single most important rule in object-oriented programming with C++ is this: public inheritance means “is-a.”
For example, a student is a person
class Person { /* ... */ }; class Student : public Person { /* ... */ }; A Student can be used anywhere a Person can be used, but not vice versa.
But NOTICE, sometimes the is-a relationship is misleading, especially when it comes to operations</description><content type="html"><![CDATA[<blockquote>
<p>Item 32: Make sure public inheritance models “is-a.”</p>
</blockquote>
<blockquote>
<p>the single most important rule in object-oriented programming with C++ is this: public inheritance means “is-a.”</p>
</blockquote>
<p>For example, a student is a person</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">Student</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Person</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</code></pre></div><p>A Student can be used anywhere a Person can be used, but not vice versa.</p>
<p>But <strong>NOTICE</strong>, sometimes the is-a relationship is misleading, especially when it comes to operations</p>
<p>For example, a Penguin is a Bird.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">Bird</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span> <span class="c1">// birds can fly
</span><span class="c1"></span>    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span> <span class="c1">// penguins are birds
</span><span class="c1"></span>    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div><p>Actually, not EVERY types of Bird can fly. There are flying birds and non-flying bird.</p>
<p>Therefore, when talking about flying, we can define a FlyingBird class.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">class</span> <span class="nc">FlyingBird</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">fly</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Penguin</span><span class="o">:</span> <span class="k">public</span> <span class="n">Bird</span> <span class="p">{</span> <span class="c1">// penguins are non-flying birds
</span><span class="c1"></span>    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div><p>However, if the system does not need to distinguish between flying or non-flying bird, the previos design is perfectly valid.</p>
<p>Another example of problematic OOD modeling:</p>
<blockquote>
<p>A Square is a Rectangle.</p>
</blockquote>
<p>We can have member variable <code>width</code> and <code>height</code> for a Rectangle class. These two varible can be set independently. But for a Square object, its <code>width</code> and <code>height</code> should always be equal.</p>
<hr>
<p>Things to remember:<br>
Public inheritance means “is-a.” Everything that applies to base classes must also apply to derived classes, because every derived class object is a base class object.</p>
]]></content></item><item><title>Effective_Modern_Cpp_Item_03</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_03/</link><pubDate>Thu, 10 Feb 2022 12:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_03/</guid><description>Item 3: Understand decltype.
使用背景 假设我们定义一个函数，接收一个容器对象Container，一个索引对象Index，先进行用户认证，然后返回容器里一个对象的引用。需要通过 decltype，才能知道容器的类型参数。
具体使用 对容器的元素类型进行推导 在cpp11中我们使用trailling type deduction的方式, 如下
// cpp 11 template&amp;lt;typename Container, typename Index&amp;gt; auto authAndAccess(Container&amp;amp; c, Index i) -&amp;gt; decltype(c[i]) { authenticateUser(); return c[i]; } 在cpp14中，可以通过decltype(auto)的方式来实现同样的功能。
如果只使用auto而不使用decltype, 则返回类型是by value， 而不是by reference。故需要使用decltype。
// cpp 14 template&amp;lt;typename Container, typename Index&amp;gt; decltype(auto) authAndAccess(Container&amp;amp; c, Index i) { authenticateUser(); return c[i]; } 同样，对于变量也可以用 decltype(auto) 来保证所推导的类型包含修饰符。
Widget w; const Widget&amp;amp; cw = w; auto myWidget1 = cw; // type: Widget decltype(auto) myWidget2 = cw; // type: const Widget&amp;amp; 对 Universal Reference 进行类型推导 前面的例子中，函数wrapFunc接收的容器类型是 Container&amp;amp;, 无法绑定临时对象（rvalue）。为了支持这一点， 可以替换成 Container&amp;amp;&amp;amp;.</description><content type="html"><![CDATA[<blockquote>
<p>Item 3: Understand decltype.</p>
</blockquote>
<h2 id="使用背景">使用背景</h2>
<p>假设我们定义一个函数，接收一个容器对象Container，一个索引对象Index，先进行用户认证，然后返回容器里一个对象的引用。需要通过 <code>decltype</code>，才能知道容器的类型参数。</p>
<h2 id="具体使用">具体使用</h2>
<h3 id="对容器的元素类型进行推导">对容器的元素类型进行推导</h3>
<p>在cpp11中我们使用<code>trailling type deduction</code>的方式, 如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// cpp 11
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">authenticateUser</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>在cpp14中，可以通过<code>decltype(auto)</code>的方式来实现同样的功能。</p>
<p>如果只使用auto而不使用decltype, 则返回类型是by value， 而不是by reference。故需要使用decltype。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// cpp 14
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">authenticateUser</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><p>同样，对于变量也可以用 <code>decltype(auto)</code> 来保证所推导的类型包含修饰符。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="n">Widget</span> <span class="n">w</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Widget</span><span class="o">&amp;</span> <span class="n">cw</span> <span class="o">=</span> <span class="n">w</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">myWidget1</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>            <span class="c1">// type: Widget
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">myWidget2</span> <span class="o">=</span> <span class="n">cw</span><span class="p">;</span>  <span class="c1">// type: const Widget&amp;
</span></code></pre></div><h3 id="对-universal-reference-进行类型推导">对 Universal Reference 进行类型推导</h3>
<p>前面的例子中，函数wrapFunc接收的容器类型是 Container&amp;, 无法绑定临时对象（rvalue）。为了支持这一点， 可以替换成 <code>Container&amp;&amp;</code>.
因此可以替换为：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="c1">// cpp 14
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">authenticateUser</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// cpp 11
</span><span class="c1"></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Index</span><span class="o">&gt;</span>
<span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">authAndAccess</span><span class="p">(</span><span class="n">Container</span><span class="o">&amp;&amp;</span> <span class="n">c</span><span class="p">,</span> <span class="n">Index</span> <span class="n">i</span><span class="p">)</span>
<span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">authenticateUser</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Container</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div><h2 id="其他需要注意的点">其他需要注意的点</h2>
<blockquote>
<p>For lvalue expressions of type T other than names, decltype always reports a
type of T&amp;.</p>
</blockquote>
<p>decltype对于所有非name的lvalue，推导的类型都是引用类型，对name的lvalue，推导类型是值类型。</p>
<p>因此要小心不要意外返回了对local变量的引用</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// decltype(x) is int, so f1 returns int
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 这里很危险！
</span><span class="c1"></span><span class="k">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">f2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// decltype((x)) is int&amp;, so f2 returns int&amp;
</span><span class="c1"></span><span class="p">}</span>

</code></pre></div>]]></content></item><item><title>Hello World</title><link>https://monsooooon.github.io/posts/hello-world/</link><pubDate>Tue, 01 Feb 2022 20:56:23 +0800</pubDate><guid>https://monsooooon.github.io/posts/hello-world/</guid><description>What ??? this is great
Sad dsfadasf
sdfdsaf
asdfdsf
sdfdsaf
123</description><content type="html"><![CDATA[<h2 id="what--">What  ???</h2>
<p>this is great</p>
<h2 id="sad">Sad</h2>
<p>dsfadasf</p>
<p>sdfdsaf</p>
<p>asdfdsf</p>
<p>sdfdsaf</p>
<p>123</p>
]]></content></item></channel></rss>