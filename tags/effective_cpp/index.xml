<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>effective_cpp on Monsooooon</title><link>https://monsooooon.github.io/tags/effective_cpp/</link><description>Recent content in effective_cpp on Monsooooon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 13 Feb 2022 15:54:32 +0800</lastBuildDate><atom:link href="https://monsooooon.github.io/tags/effective_cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective_Cpp_Item_36</title><link>https://monsooooon.github.io/posts/effective_cpp_item_36/</link><pubDate>Sun, 13 Feb 2022 15:54:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_36/</guid><description>Item 36: Never redefine an inherited non-virtual function.
non-virtual member functions are not very good to hide
let&amp;rsquo;s say you have class D and class B. D inherts from B. they both have a member function mf().
#include &amp;lt;iostream&amp;gt; class B { public: void mf() { std::cout &amp;lt;&amp;lt; &amp;#34;B::mf&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class D : public B { public: void mf() { std::cout &amp;lt;&amp;lt; &amp;#34;D::mf&amp;#34; &amp;lt;&amp;lt; std::endl; } }; then calling</description></item><item><title>Effective_Cpp_Item_34</title><link>https://monsooooon.github.io/posts/effective_cpp_item_34/</link><pubDate>Thu, 10 Feb 2022 14:48:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_34/</guid><description>Item 34: Differentiate between inheritance of interface and inheritance of implementation.
there are 3 types of member functions
pure virtual functions simple(impure) virtual functions non-virtual functions They differs in the way whether derived classes should inherit the interface or implementation:
Pure virtual functions specify inheritance of interface only. Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation. Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation.</description></item><item><title>Effective_Cpp_Item_33</title><link>https://monsooooon.github.io/posts/effective_cpp_item_33/</link><pubDate>Thu, 10 Feb 2022 14:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_33/</guid><description>Item 33: Avoid hiding inherited names.
In Cpp, names be be hidden.
for example:
double x; void func() { int x; cin &amp;gt;&amp;gt; x; // read the int x, not the double x; } the name searching rule is bottom-up, from local to larget scope, and finally to global scope.
the same rule applies to member functions in inheritance.
class Base { private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); .</description></item><item><title>Effective_Cpp_Item_32</title><link>https://monsooooon.github.io/posts/effective_cpp_item_32/</link><pubDate>Thu, 10 Feb 2022 13:43:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_32/</guid><description>Item 32: Make sure public inheritance models “is-a.”
the single most important rule in object-oriented programming with C++ is this: public inheritance means “is-a.”
For example, a student is a person
class Person { /* ... */ }; class Student : public Person { /* ... */ }; A Student can be used anywhere a Person can be used, but not vice versa.
But NOTICE, sometimes the is-a relationship is misleading, especially when it comes to operations</description></item></channel></rss>