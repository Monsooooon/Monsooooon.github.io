<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on Monsooooon</title><link>https://monsooooon.github.io/tags/cpp/</link><description>Recent content in cpp on Monsooooon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 13 Feb 2022 16:34:32 +0800</lastBuildDate><atom:link href="https://monsooooon.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Effective_Cpp_Item_37</title><link>https://monsooooon.github.io/posts/effective_cpp_item_37/</link><pubDate>Sun, 13 Feb 2022 16:34:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_37/</guid><description>Item 37: Never redefine a function’s inherited default parameter value.
virtual functions are dynamically bound, but default parameter values are statically bound.
you should avoid adding default param to virtual functions
let&amp;rsquo;s say you have two class B &amp;amp; D. D is derived from B.
class B { virtual void mf(int i = 1) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } }; class D : public B { virtual void mf(int i = 2) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } }; D x; x.</description></item><item><title>Effective_Cpp_Item_38</title><link>https://monsooooon.github.io/posts/effective_cpp_item_38/</link><pubDate>Sun, 13 Feb 2022 16:34:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_38/</guid><description>Item 38: Model “has-a” or “is-implemented-in-terms- of” through composition.
Composition means either “has-a” or “is-implemented-in-terms-of.”
Let&amp;rsquo;s say that you want to implement a Set class that need less space than the standard std::set. You want to use std::list
you probably use
template&amp;lt;typename T&amp;gt; class MySet: std::list&amp;lt;T&amp;gt; { ... }; but that is QUITE WRONG!!!
by using public inheritance, you are saying that a MySet object is-a std::list type.</description></item><item><title>Effective_Cpp_Item_36</title><link>https://monsooooon.github.io/posts/effective_cpp_item_36/</link><pubDate>Sun, 13 Feb 2022 15:54:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_36/</guid><description>Item 36: Never redefine an inherited non-virtual function.
non-virtual member functions are not very good to hide
let&amp;rsquo;s say you have class D and class B. D inherts from B. they both have a member function mf().
#include &amp;lt;iostream&amp;gt; class B { public: void mf() { std::cout &amp;lt;&amp;lt; &amp;#34;B::mf&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class D : public B { public: void mf() { std::cout &amp;lt;&amp;lt; &amp;#34;D::mf&amp;#34; &amp;lt;&amp;lt; std::endl; } }; then calling</description></item><item><title>Effective_Modern_Cpp_Item_21</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_21/</link><pubDate>Fri, 11 Feb 2022 09:38:45 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_21/</guid><description>Item 21: Prefer std::make_unique and std::make_shared to direct use of new.
three make functions
std::make_unique std::make_shared std::allocate_shared how to use? // deprecated: std::unique_ptr&amp;lt;Widget&amp;gt; upw(new Widget); auto upw(std::make_unique&amp;lt;Widget&amp;gt;()); // deprecated: std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget); auto spw(std::make_shared&amp;lt;Widget&amp;gt;()); why use? exception safety consider the following code:
processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), computePriority()); possible execution order (depends on compiler)
new Widget computerPriority &amp;ndash;&amp;gt; cause exception!! build shared_ptr if the second step throws an exception, the new-ed Widget will NEVER be deleted.</description></item><item><title>Effective_Modern_Cpp_Item_23</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_23/</link><pubDate>Fri, 11 Feb 2022 09:38:45 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_23/</guid><description>Item 23: Understand std::move and std::forward.
our focus:
std::move std::forward they are functions.
std::move std::move casts its arguement to an rvalue. it&amp;rsquo;s better to call it &amp;lsquo;rvalue cast&amp;rsquo;.
it does the cast. it doesn&amp;rsquo;t move.
in some cases, the std::move-ed object is still copied, not moved
class Annotation { public: Annotation(const std::string text): value(std::move(text)) { // try move text (call string&amp;#39;s move ctor) //... } private: std::string value; } class string { public: string(const string&amp;amp; rhs); // copy ctpr string(string&amp;amp;&amp;amp; rhs); // move ctor // .</description></item><item><title>Effective_Cpp_Item_34</title><link>https://monsooooon.github.io/posts/effective_cpp_item_34/</link><pubDate>Thu, 10 Feb 2022 14:48:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_34/</guid><description>Item 34: Differentiate between inheritance of interface and inheritance of implementation.
there are 3 types of member functions
pure virtual functions simple(impure) virtual functions non-virtual functions They differs in the way whether derived classes should inherit the interface or implementation:
Pure virtual functions specify inheritance of interface only. Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation. Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation.</description></item><item><title>Effective_Cpp_Item_33</title><link>https://monsooooon.github.io/posts/effective_cpp_item_33/</link><pubDate>Thu, 10 Feb 2022 14:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_33/</guid><description>Item 33: Avoid hiding inherited names.
In Cpp, names be be hidden.
for example:
double x; void func() { int x; cin &amp;gt;&amp;gt; x; // read the int x, not the double x; } the name searching rule is bottom-up, from local to larget scope, and finally to global scope.
the same rule applies to member functions in inheritance.
class Base { private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); .</description></item><item><title>Effective_Cpp_Item_32</title><link>https://monsooooon.github.io/posts/effective_cpp_item_32/</link><pubDate>Thu, 10 Feb 2022 13:43:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_cpp_item_32/</guid><description>Item 32: Make sure public inheritance models “is-a.”
the single most important rule in object-oriented programming with C++ is this: public inheritance means “is-a.”
For example, a student is a person
class Person { /* ... */ }; class Student : public Person { /* ... */ }; A Student can be used anywhere a Person can be used, but not vice versa.
But NOTICE, sometimes the is-a relationship is misleading, especially when it comes to operations</description></item><item><title>Effective_Modern_Cpp_Item_03</title><link>https://monsooooon.github.io/posts/effective_modern_cpp_item_03/</link><pubDate>Thu, 10 Feb 2022 12:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/effective_modern_cpp_item_03/</guid><description>Item 3: Understand decltype.
使用背景 假设我们定义一个函数，接收一个容器对象Container，一个索引对象Index，先进行用户认证，然后返回容器里一个对象的引用。需要通过 decltype，才能知道容器的类型参数。
具体使用 对容器的元素类型进行推导 在cpp11中我们使用trailling type deduction的方式, 如下
// cpp 11 template&amp;lt;typename Container, typename Index&amp;gt; auto authAndAccess(Container&amp;amp; c, Index i) -&amp;gt; decltype(c[i]) { authenticateUser(); return c[i]; } 在cpp14中，可以通过decltype(auto)的方式来实现同样的功能。
如果只使用auto而不使用decltype, 则返回类型是by value， 而不是by reference。故需要使用decltype。
// cpp 14 template&amp;lt;typename Container, typename Index&amp;gt; decltype(auto) authAndAccess(Container&amp;amp; c, Index i) { authenticateUser(); return c[i]; } 同样，对于变量也可以用 decltype(auto) 来保证所推导的类型包含修饰符。
Widget w; const Widget&amp;amp; cw = w; auto myWidget1 = cw; // type: Widget decltype(auto) myWidget2 = cw; // type: const Widget&amp;amp; 对 Universal Reference 进行类型推导 前面的例子中，函数wrapFunc接收的容器类型是 Container&amp;amp;, 无法绑定临时对象（rvalue）。为了支持这一点， 可以替换成 Container&amp;amp;&amp;amp;.</description></item></channel></rss>