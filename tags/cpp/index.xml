<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on Monsooooon</title><link>https://monsooooon.github.io/tags/cpp/</link><description>Recent content in cpp on Monsooooon</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 11 Feb 2022 09:38:45 +0800</lastBuildDate><atom:link href="https://monsooooon.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>Item_21_Prefer_std_make_unique_and_std_make_shared_to_direct_use_of_new</title><link>https://monsooooon.github.io/posts/item_21_prefer_std_make_unique_and_std_make_shared_to_direct_use_of_new/</link><pubDate>Fri, 11 Feb 2022 09:38:45 +0800</pubDate><guid>https://monsooooon.github.io/posts/item_21_prefer_std_make_unique_and_std_make_shared_to_direct_use_of_new/</guid><description>three make functions
std::make_unique std::make_shared std::allocate_shared how to use? // deprecated: std::unique_ptr&amp;lt;Widget&amp;gt; upw(new Widget); auto upw(std::make_unique&amp;lt;Widget&amp;gt;()); // deprecated: std::shared_ptr&amp;lt;Widget&amp;gt; spw(new Widget); auto spw(std::make_shared&amp;lt;Widget&amp;gt;()); why use? exception safety consider the following code:
processWidget(std::shared_ptr&amp;lt;Widget&amp;gt;(new Widget), computePriority()); possible execution order (depends on compiler)
new Widget computerPriority &amp;ndash;&amp;gt; cause exception!! build shared_ptr if the second step throws an exception, the new-ed Widget will NEVER be deleted.
correct way with std::make_shared:</description></item><item><title>Item3_decltype</title><link>https://monsooooon.github.io/posts/item3_decltype/</link><pubDate>Thu, 10 Feb 2022 12:09:32 +0800</pubDate><guid>https://monsooooon.github.io/posts/item3_decltype/</guid><description>使用背景 假设我们定义一个函数，接收一个容器对象Container，一个索引对象Index，先进行用户认证，然后返回容器里一个对象的引用。需要通过 decltype，才能知道容器的类型参数。
具体使用 对容器的元素类型进行推导 在cpp11中我们使用trailling type deduction的方式, 如下
// cpp 11 template&amp;lt;typename Container, typename Index&amp;gt; auto authAndAccess(Container&amp;amp; c, Index i) -&amp;gt; decltype(c[i]) { authenticateUser(); return c[i]; } 在cpp14中，可以通过decltype(auto)的方式来实现同样的功能。
如果只使用auto而不使用decltype, 则返回类型是by value， 而不是by reference。故需要使用decltype。
// cpp 14 template&amp;lt;typename Container, typename Index&amp;gt; decltype(auto) authAndAccess(Container&amp;amp; c, Index i) { authenticateUser(); return c[i]; } 同样，对于变量也可以用 decltype(auto) 来保证所推导的类型包含修饰符。
Widget w; const Widget&amp;amp; cw = w; auto myWidget1 = cw; // type: Widget decltype(auto) myWidget2 = cw; // type: const Widget&amp;amp; 对 Universal Reference 进行类型推导 前面的例子中，函数wrapFunc接收的容器类型是 Container&amp;amp;, 无法绑定临时对象（rvalue）。为了支持这一点， 可以替换成 Container&amp;amp;&amp;amp;.</description></item></channel></rss>